= Интерполяция функции одного аргумента

== Постановка задачи интерполяции

#v(1em) // TODO: add auto padding for heading
Пусть задана дискретным набором своих значений некоторая функция $f$, а именно: данная функция определена таблицей следующих значений:

#table(align: center, columns: (1fr, 1fr, 1fr, 1fr, 1fr), rows: (
    auto,
    auto,
  ))[$x$][$x_0$][$x_1$][$...$][$x_n$][$f$][$f_0$][$f_1$][$...$][$f_n$]

Требуется построить непрерывную на некоторой области функцию $g(x)$, такую чтобы выполнялись условия, называемые главным условием интерполяции (ГУИ):

$ g(x_k) = f_k,space forall k in overline(0\, n) $ <eq:eq1>

#figure(
  image("images/2025-09-02-interpolation.png", width: 50%),
  caption: "Задача интерполяции функции одной переменной. Вне узловых точек может быть отклонение",
)

Итак, цель: по *дискретным* значениям построить *непрерывную* функцию.

/ Определение.: Точки $x_0, x_1, ..., x_n$ называются узлами *интерполяции* (приближения).

/ Определение.: Функция $f: (x_k, f_k) space forall k in overline(0\, n)$ называется *интерполируемой* (приближаемой) функцией.

/ Определение.: Функция $g(x)$, удовлетворяющая условиям (@eq:eq1) называется *интерполирующей* (интерполяционной, приближающей) функцией. Короче: *интерполянта*.

/ Определение.: Условия (@eq:eq1) называются *главным условием интерполяции (ГУИ)*.

В сформулированной постановке задачи интерполяции можно указать, очевидно, в качестве искомой интерполянты _бесконечное_ число непрерывных функций. Сверх того: их _несчётное_ число!

Но сформулировали мы задачу нехорошо: решение не единственное. Но мы намеренно начинаем с азов. Разбираться в деталях будем позже.

== Интерполяционный\* многочлен в общем виде

\*вообще говоря, правильно интерполирующий

В этом параграфе покажем, что в качестве искомой интерполянты задачи интерполяции (ЗИ) может быть предложен алгебраический многочлен степени $n$, построенный по $(n+1)$ попарно различному узлу интерполяции.

Забудем пока про это. Сначала проведём исследования, а потом будем делать выводы.

В аналитической геометрии доказано, что алгебраический многочлен первой степени задаёт прямую. Второй --- параболу, третьей --- кубическую параболу, и так далее. Раз у нас точек от 0 до $n$ в ЗИ, то по предположению индукции для \ $(n+1)$ узла следует взять многочлен $n$-го порядка.

Таким образом, для $(n+1)$ узла интерполяции $x_0, x_1, ..., x_n$ попробуем построить алгебраический многочлен:
$ p_n (x) = a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0. $ <eq:eq2>

Потребуем, чтобы (@eq:eq2) удовлетворял (@eq:eq1), то есть:

$
  cases(
    delim: "{",
    p_n (x_0) = f_0 comma,
    p_n (x_1) = f_1 comma,
    ...,
    p_n (x_n) = f_n comma
  ) space <=> space cases(
    delim: "{",
    a_n x_0^n + a_(n-1) x_0^(n-1) + ... + a_1 x_0 + a_0 = f_0 comma,
    a_n x_1^n + a_(n-1) x_1^(n-1) + ... + a_1 x_1 + a_0 = f_1 comma,
    ...,
    a_n x_n^n + a_(n-1) x_n^(n-1) + ... + a_1 x_n + a_0 = f_n.
  )
$ <eq:eq3>

Равенства (@eq:eq3) по своей алгебраической природе представляют собой СЛАУ размерности $(n+1) times (n+1)$ относительно неизвестных коэффициентов интерполяции $a_0, a_1, ..., a_n$. Чтобы её решить, необходимо, чтобы её главный определитель был отличен от нуля:

$
  Delta_(\(#text([@eq:eq3])\)) = mat(delim: "|",
    x_0^n, x_0^(n-1), ..., x_0, 1;
    x_1^n, x_1^(n-1), ..., x_1, 1;
    dots.v, dots.v, dots, dots.v, dots.v;
    x_n^n, x_n^(n-1), ..., x_n, 1
  ) = limits(Pi)_(j > i)(x_j - x_i)
$ <eq:eq4>

Чтобы (@eq:eq4) был отличен от нуля необходимо, чтобы:
$ forall i != j space x_i != x_j. $ <eq:eq5>

Условие (@eq:eq5) называется условием попарной различности узлов интерполяции.

Таким образом, из выше изложенного можем получить следующее: при условии (@eq:eq5) определитель (@eq:eq4) отличен от нуля, а значит (@eq:eq3) имеет единственное решение. Таким образом, решив (@eq:eq3) каким-либо подходящим численным методом найдём её единственное решение, а именно значение искомых коэффициентов $a_0, a_1, ..., a_n$. В свою очередь, найдя эти коэффициенты и подставив их в исходное представление (@eq:eq2), мы получим *явную аналитическую форму* для исходного представления интерполянты:

$ p_n (x) = a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0, $ <eq:eq6>

только теперь мы точно знаем все коэффициенты. При этом, если изменить степень, то тогда изменится размерность СЛАУ, что приведёт к потери однозначности решения.

Получили конкретный алгоритм, который можно запрограммировать.