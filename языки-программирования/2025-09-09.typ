= 9 сентября 2025

Перейдём к циклам. Циклы реализуют *итерацонные процессы*.

Реализуем цикл Фибоначчи на псевдокоде:

#pagebreak(weak: true)

```
-> n
i = 0
a_0 = 0
a_1 = 1

while (i < n) {
  a_2 = a_0 + a_1
  i++
  a_0 = a_1
  a_1 = a_2

  a_0 ->
}
```

Цикл зависит от каких-то параметров: $C(i, a_0, a_1, n)$. От этих параметров зависит весь итерационный процесс.

С другой стороны, изначально состояние цикла: $C(0, 0, 1, 8)$. Потом оно выдаст нам результат в виде $a_0 = 21$. Можем задать цикл и с другим начальным состоянием: $   C(1, 1, 1, 8) space & => 21 \
  C(2, 1, 2, 8) space & => 21 \
                  ... \
C(8, 21, 34, 8) space & => 21 space (0 "шагов цикла"). $

Короче: можно начать с любого шага, но вычислений будет меньше. В целом для итерационного процесса характерно, что:
$
  C(x_1) = C(x_2),
$

где $x_1, x_2$ -- какие-то наборы аргументов (возможно различные).

В языке SML *нет конструкции цикла*. Вместо этого мы будем использовать *рекурсию*:

$
  "fib"(n) = cases(delim: "{", 0\, & space n = 0\,, 1\, & space n = 1\,, "fib"(n-1) + "fib"(n-2)\, & space n > 1.)
$

#pagebreak(weak: true)

В языке SML всё совсем просто:

```sml
fun fib(n: int): int =
  if n = 0 then 0
  else if n = 1 then 1
  else fib(n - 1) + fib(n - 2)
```

Для вычисления значения функции воспользуемся *подстановочной моделью*: в место вызова функции подставляется её тело.

Так, выражение ```sml fib(5)``` заменится на ветвление, внутри которого вызываются ```sml fib(4)``` и ```sml fib(3)```. Эти выражения также заменяются на ветвления со следующими выражениями: ```sml fib(3)```, ```sml fib(2)```, ```sml fib(2)```, ```sml fib(1)```. Все выражения также заменяются на ветвления, в которых будут выражения: ```sml fib(2)```, ```sml fib(1)```, ```sml fib(1)```, ```sml fib(0)```. И мы постепенно приходим к тривиальным случаям.

```
0. fib(5)
  1. fib(4) + fib(3)
    2. fib(3) + fib(2)
      3. fib(2) + fib(1)
        4. fib(1) + fib(0)
          5. 1
          5. 0
        4. 1
      3. fib(1) + fib(0)
        4. 1
        4. 0
    2. fib(2) + fib(1)
      3. fib(1) + fib(0)
        4. 1
        4. 0
      3. 0
0. 21
```

Вообще говоря, любой цикл можно переписать через рекурсию.

*Фан факт*: запишем функцию факториала:

```sml
fun fact(n: int): int =
  if n > 0 then n * fact(n - 1)
  else 1
```

Вывод рекурсии (как листинг ранее) может быть двух видов: *древовидным*,  как для чисел Фибоначчи, или *линейным*, как для факториала.

Запишем программу для вычисления чисел Фибоначчи через "циклы":

```sml
fun C(i: int, a_0: int, a_1: int, n: int): int =
  if i < n then C(i + 1, a_1, a_0 + a_1, n)
  else a_0
```

Так, для вычисления 8 числа Фибоначчи, нужно вызвать ```sml C(0, 0, 1, 8)```. Сверх того: это будет быстрее, чем рекурсия.

Многие компиляторы, поддерживающие рекурсию, сводят циклы к рекурсиям. Такие функции называют хвостовыми рекурсиями:

/ Хвостовая рекурсия: --- это функция такая, что любой рекурсивный вызов в её теле приводит к получению результата всего вызова функции.

Опишем рекурсивную функцию ```sml odd```:

```sml
fun even(n: int): bool =
  if n = 0 then true
  else odd(n - 1)

fun odd(n: int): bool =
  if n = 1 then true
  else even(n - 1)
```

== Основные структуры и типы данных в SML

=== Машинные типы данных

- ```sml int``` --- целые числа. Важно: унарный минус это ```sml ~``` (т.е.: ```0 - 25 = ~25```). В зависимости от разрядности представляет собой `int64` или `int32`
- ```sml real``` --- действительные числа
- ```sml bool``` --- логический тип. В SML строгая типизация, поэтому нельзя написать что-то в духе ```c while(1)```

=== Контейнеры

+ *Списки.* Записываются как ```sml <type> list```. Например, ```sml int list```. Могут быть многомерными: ```sml int list list```.

```sml
val l = [1, 5, 7, 8]
```

+ *Кортежи.* Тоже перечисление, но в круглых скобках и иммутабельное. Может представлять много типов, сам же имеет тип совокупности своих типов.

```sml
(2, 3, 5, "sex") (* Тип int * int * int * string *)
```

=== Сложные типы

Можно объявить свой тип данных:

```sml
type date = int * int * int
```

Также можно описать запись (как структура):

```sml
{
  name: "Sergei",
  year: 2025,
  num: 3517,
  deg: 3.15
}
```

== Ключевые слова в SML

- ```sml andalso``` --- логическое И
- ```sml orelse``` --- логическое ИЛИ
- ```sml not``` --- логическое НЕ
- ```sml ^``` --- конкатенация строк
- ```sml #i``` --- извлечение из контейнера:

```sml
val penis_params = (69, 45, 1488, 0) 
val length = #4(penis_params)
```

Для структур аналогично, но вместо ```sml i``` используем имя поля.

*Важно!* Все значения иммутабельны.

== Идиомы SML

Можно создавать списки:

```sml
val l = 1::2::3::4::5::6::9::[] (* cons -- англ. consolidate *)
```

Общий вид конса:

```sml
a::b
```

Второй параметр обязательно имеет тип списка, а первый --- тип элемента этого списка.

== Map

Реализуем ```sml map```:

```sml
fun map(f: 'a -> 'b, l: 'a list): 'b list =
  if null l then nil
  else f(hd l)::map(f, tl l)

fun sq(x: int): int = x * x

val l = [1, 2, 3]
val l_sq = map(sq, l)
val l_qu =  map(sq o sq, l)
```

== Анонимные функции

```sml
fn(x: int): int => x * x
fn x => x * x
```