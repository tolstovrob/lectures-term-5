= 2 сентября 2025

== Парадигмы программирования

=== Императивное программирование

/ Императивное программирование: --- это подход, предполагающий, что мы отдаём команды исполнителю и оно их последовательно выполняет.

Побочные эффекты в императивном подходе, например, выполняет оператор присваивания.

Оператор (команда) $!=$ операция. Раньше, в языках низкого уровня везде использовались операторы (суммы, разности, т.п.). В языках высокого уровня сложение --- это операция, так как тут это не команда, а _часть команды_.

Например, в коде `a := a + b` знак `+` --- это операция, а `a := a + b` --- оператор (присваивания).

/ Чистая функция: --- код без побочных эффектов.

Ещё примеры операторов в императивном подходе:

- Оператор ветвления: `if (выражение) {} else {}`;
- Оператор цикла: `while (выражение) {}`;
- Команды вывода.

=== Декларативное программирование

/ Функциональное программирование: --- одна из разновидностей декларативного программирования.

Ещё есть под-парадигмы:

- Логическое программирование;
- Объектно-ориентированное программирование.

Наш первый язык для входа в функциональщину --- Standart ML. Мы задаём набор аксиом и фактов, а затем формулируем то, чем должен являться результат на основании заданных аксиом и фактов.

В ФЯП всё похоже: определяем функции, а дальше говорим, что нашим ответом будет результат вызова этих функций.

$ f: S_1 times S_2 times ... times S_n -> S $

Будем называть функцию *чистой*, если её результат зависит только от её параметров и не зависит от внешней среды, и, при вычислении рещультата, функция не оставляет никаких побочных эффектов. Кроме того, функция должна вызываться только ради *результата*.

Пока не будем думать о хранении результата. Он просто выдаётся.

== Standart ML

Напишем функцию для сложения:

```sml
fun f(a: int, b: int): int = 2 * a + b
```

ВАЖНО: ознакомиться с правилами оформления программ на курсе.

Общий синтаксис объявления функции:

```sml
fun <имя_функции>(аргументы): тип_результата = результат
```

Эту же функцию можно переписать так:

```sml
fun f(a: int, b: int): int = (op +)((op *)(2, a), b)
```

Мы также можем не просто вернуть значение, но и перечислить выражения через точку с запятой в скобках:

```sml
(выр_1; выр_2; выр_3; ...; выр_n)
```

Напшем функцию для суммы квадратов трёх чисел:

```sml
fun f1(a: int, b: int, c: int): int = a * a + b * b + c * c
```

Было бы выгоднее реализовать функцию для квадрата. Сделаем так:

```sml
fn square(a: int): int = a * a
```

И тогда получим:

```sml
fun f1(a: int, b: int, c: int): int = square(a) + square(b) + square(c)
```

Но! В решении нельзя использовать вспомогательные функции, так как это побочный эффект.

Рассмотрим другой пример: функция длины радиус-вектора в трёхмерном пространстве:

```sml
fun f2(x1: real, y1: real, x2: real, y2: real, x3: real, y3: real): real = (x3-x1)*(x2-x1) + (y2-y1)*(y3-y1)
```

Было бы круто иметь какое-то вспомогательное имя. С другой стороны, не хочется объявлять глобальную функцию (как `square`).

И тут мы можем использовать составные выражения. Так, мы можем написать:

```sml
let
  <декларации>
in
  <выражения>
end 
```

Декларацию можно определить так:

```sml
val имя = выражение
```

Перепишем 1 пример:

```sml
fun f1(a: int, b: int, c: int): int = let
    fun square(a: int, b: int): int = a * a
  in
    square(a) + square(b) + square(c)
  end
```

Во 2 примере ввеём вспомогательные значения:

```sml
fun f2(x1: real, y1: real, x2: real, y2: real, x3: real, y3: real): real = let
    val dx21 = (x2-x1)
    val dy21 = (y2-y1)
    val dx31 = (x3-x1) 
    val dy31 = (y3-y1)
  in
    dx21 * dx21 + dy21 * dy21 + dx31 * dx31 + dy31 * dy31
  end
```

Важно: ```sml val``` --- это не оператор присваивания, а оператор связывания.
